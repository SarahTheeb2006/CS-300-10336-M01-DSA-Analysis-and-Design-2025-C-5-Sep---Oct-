# CS-300-10336-M01-DSA-Analysis-and-Design-2025-C-5-Sep---Oct-

The fundamental difficulty I solved in these projects was to develop and implement efficient data structures for organizing and retrieving course information for the Computer Science curriculum. The purpose was to develop a functional advising assistance application that could import course data from a file, store it in an appropriate data structure, and show the course list in alphabetical order. To establish which data structures, such as vectors, hash tables, and binary search trees, would be most effective for storing and sorting the data, the runtime and memory usage of each was examined. 

	To tackle this challenge, I examined the advantages and disadvantages of each data structure. I looked at how each one performs insertion, searching, and traversal actions. Understanding data structures is critical because they directly affect how quickly a program runs and how much memory it consumes. I picked a binary search tree because of its efficient O(log n) lookup and sorting capabilities, which enabled the application to dynamically organize the course list in order as new data was entered. 

	Throughout the projects, I had numerous challenges, particularly while implementing file input and troubleshooting logical faults connected to data insertion and traversal. I resolved these challenges by going over algorithm logic, using debugging tools in my IDE, and breaking down complicated problems into smaller parts. I also checked my runtime analysis to ensure that the program's performance was consistent with my expectations. 

	Working on these projects broadened my perspective on software design, allowing me to think critically about efficiency and scalability. I discovered that selecting the appropriate data structure early in the design process helps minimize performance bottlenecks and make the code easier to maintain. It also emphasized the significance of modular programming, which separates code into distinct, reusable functions. 

	Finally, this experience helped me build programs that are maintainable, readable, and adaptive. I used consistent naming standards, included extensive comments, and structured my code so that future changes (such as switching to a new data structure) could be simply implemented. These behaviors have improved my ability to create software that is not only effective but also durable and professional for long-term use. 
